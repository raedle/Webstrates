'use strict';

const crypto = require('crypto');
const fs = require('fs');
const htmlToJsonML = require('html-to-jsonml');
const mime = require('mime-types');
const shortId = require('shortid');
const multer = require('multer');
const yauzl = require('yauzl');
const permissionManager = require(APP_PATH + '/helpers/PermissionManager.js');
const clientManager = require(APP_PATH + '/helpers/ClientManager.js');
const assetManager = require(APP_PATH + '/helpers/AssetManager.js');
const documentManager = require(APP_PATH + '/helpers/DocumentManager.js');
const niceWebstrateIds = require(APP_PATH + '/helpers/niceWebstrateIds.js');

// Upload function generated by Multer.
const upload = multer({
	storage: multer.memoryStorage(),
	limits: { fileSize: (config.maxAssetSize || 20) * 1024 * 1024 }, // 20 MB default.
}).any();

/**
 * Handles webstrate document upload.
 * @param  {obj} req Express request object.
 * @param  {obj} res Express response object.
 * @public
 */
module.exports.uploadAndImport = async function (req, res) {
	upload(req, res, async function (err) {
		if (err) {
			console.error(err);
			return res.status(409).json(err.code === 'LIMIT_FILE_SIZE' ?
				{ error: `Maximum file size exceeded (${(config.maxAssetSize || 20)} MB).` } : err);
		}

		if (!req.files) {
			return res.status(422).json({ error: 'Parameter missing from request.' });
		}

		try {
			const webstrateId = await module.exports.importWebstrateFromArchiveBuffer(req, res,
				req.files[0].buffer);
			const importMessage = {
				webstrateId: webstrateId
			};

			// Send webstrate id of imported webstrate document as response to client.
			res.json(importMessage);

			// Trigger import event on webstrate object.
			clientManager.announceImport(req.webstrateId, importMessage, true);
		}
		catch (err) {
			console.error(err);
		}
	});
};

/**
 * Transform a readable straem into a string
 * @param  {ReadableStream} stream Stream to read from.
 * @param  {Function} callback     Callback to call when stream has been read.
 * @return {string}                (async) String read from stream.
 * @private
 */
function streamToString(stream, callback) {
	let str = '';
	stream.on('data', chunk => str += chunk);
	stream.on('end', () => callback(str));
}

async function generateWebstrateId(req) {
	if (config.niceWebstrateIds) {
		const startingLetter = req.user.userId !== 'anonymous:' && req.user.username.charAt(0);
		return await niceWebstrateIds.generate(startingLetter);
	} else {
		return shortId.generate();
	}
}

/**
 * Replaces a string with another string in the attribute names of a JsonML structure.
 * Webstrate code usually handles this.
 * @param  {JsonML} snapshot    JsonML structure.
 * @param  {string} search      String to search for. Regex also works.
 * @param  {string} replacement String to replace search with.
 * @return {JsonML}             JsonML with replacements.
 * @private
 */
function replaceInKeys(jsonml, search, replacement) {
	if (Array.isArray(jsonml)) {
		return jsonml.map(e => replaceInKeys(e, search, replacement));
	}
	if (typeof jsonml === 'object') {
		for (const key in jsonml) {
			const cleanKey = key.replace(search, replacement);
			jsonml[cleanKey] = replaceInKeys(jsonml[key], search, replacement);
			if (cleanKey !== key) {
				delete jsonml[key];
			}
		}
	}
	return jsonml;
}

/**
 * Reads the buffer as zip archive and tries to import its contents as a webstrate
 * document. The function returns a promise that resolves to an object containing the
 * imported document's webstrateId as property.
 * @param {obj} req Express request object.
 * @param {obj} res Express response object
 * @param {array} buffer Zip archive buffer.
 */
module.exports.importWebstrateFromArchiveBuffer = async function (req, res, buffer) {
	return new Promise((resolve, reject) => {

		// Reading zip archive from buffer.
		yauzl.fromBuffer(buffer, { lazyEntries: true }, (err, zipArchive) => {
			if (err) {
				return reject(err);
			}

			let webstrateId, htmlDocumentFound = false;
			let assets = [];
			zipArchive.on('entry', entry => {
				if (/\/$/.test(entry.fileName)) {
					// Directory file names end with '/'.
					// Note that entries for directories themselves are optional.
					// An entry's fileName implicitly requires its parent directories to exist.
					zipArchive.readEntry();
				} else {
					// file entry
					zipArchive.openReadStream(entry, (err, readStream) => {
						if (err) return console.error(err);
						readStream.on('end', function () {
							zipArchive.readEntry();
						});

						if (!htmlDocumentFound && entry.fileName.match(/index\.html?$/i)) {
							htmlDocumentFound = true;
							streamToString(readStream, async htmlDoc => {
								let jsonml = htmlToJsonML(htmlDoc);
								// MongoDB doesn't accept periods in keys, so we replace them with
								// `&dot;`s when storing them in the database.
								jsonml = replaceInKeys(jsonml, '.', '&dot;');
								let snapshot = {
									type: 'http://sharejs.org/types/JSONv0',
									data: jsonml
								};
								const userPermissions = await permissionManager
									.getUserPermissionsFromSnapshot(req.user.username, req.user.provider,
										snapshot);
								// If user doesn't have write permissions to the docuemnt, add them if
								// the user is logged in, otherwise just delete all permissions on the
								// new document.
								if (!userPermissions.includes('w')) {
									if (req.user.username === 'anonymous' && req.user.provider === '') {
										snapshot = permissionManager.clearPermissionsFromSnapshot(snapshot);
									} else {
										snapshot = permissionManager
											.addPermissionsToSnapshot(req.user.username, req.user.provider,
												'rw', snapshot);
									}
								}

								documentManager.createNewDocument({
									webstrateId: req.query.id || await generateWebstrateId(req),
									snapshot
								}, function (err, _webstrateId) {
									if (err) {
										console.error(err);
										return;
									}
									webstrateId = _webstrateId;
								});
							});
						}
						else {
							crypto.pseudoRandomBytes(16, (err, raw) => {
								if (err) {
									return reject(err);
								}

								const fileName = raw.toString('hex');
								const filePath = assetManager.UPLOAD_DEST + fileName;
								const writeStream = fs.createWriteStream(filePath);
								readStream.pipe(writeStream);
								assets.push({
									filename: fileName,
									originalname: entry.fileName.match(/([^/]+)$/)[0],
									size: entry.uncompressedSize,
									mimetype: mime.lookup(entry.fileName)
								});
							});
						}
					});
				}
			});

			function addAssetsToWebstrateOrDeleteTheAssets() {
				if (!webstrateId) {
					assets.forEach(asset => {
						fs.unlink(assetManager.UPLOAD_DEST + asset.filename, () => { });
					});
					return res.status(409).send(htmlDocumentFound
						? 'Unable to create webstrate from index.html file.'
						: 'No index.html found.');
				}

				var source = `${req.user.userId} (${req.remoteAddress})`;
				// Assets ending in .searchable aren't real assets, but just an indication that
				// the asset they're referring to should be searchable. E.g. if two assets
				// data.csv and data.csv.searchable are uploaded, the ladder just serves to let us
				// know that the former should be made searchable.
				let searchables = assets.filter(asset =>
					asset.originalname.endsWith('.searchable'));

				// Remove dummy files from assets list.
				assets = assets.filter(asset =>
					!asset.originalname.endsWith('.searchable'));

				// Delete the dummy files from the system.
				searchables.forEach(asset => {
					fs.unlink(assetManager.UPLOAD_DEST + asset.filename, () => { });
				});

				// Now create a simple list (no objects, just asset nameS) of the asset names
				// that should be searchable. We remember to remove the 11-character long
				// '.searchable'  prefix.
				searchables = searchables.map(asset => asset.originalname.slice(0, -11));
				assetManager.addAssets(webstrateId, assets, searchables, source,
					(err, assetRecords) => {
						// Return with webstrate id after document import and assets upload
						// finished.
						resolve(webstrateId);
					});
			}

			zipArchive.once('end', function () {
				zipArchive.close();

				if (webstrateId) {
					return addAssetsToWebstrateOrDeleteTheAssets();
				}

				// If no webstrateId exists, we're waiting for MongoDB, so we'll wait 500ms.
				setTimeout(addAssetsToWebstrateOrDeleteTheAssets, 500);
			});

			zipArchive.readEntry();
		});
	});
};